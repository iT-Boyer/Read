# Graphql实战

# GraphQL API设计和全栈开发

## 1.7 GraphQL引发的疑虑

### 1.7.2 GraphQL增大了后端系统设计的难度

Graphql的系统设计中, 要特别注意模块间的耦合问题, 切忌把所有模块都搅和在一起

# 5 基于Go语言协程的GraphQL服务

## 5.1 使用协程的原因

- 进程有自己独享的堆栈
- 线程共享堆, 但是有自己独享的栈
- 协程同样是共享堆, 有自己独享的栈
- 进程和线程都由操作系统调度, 一般来说调度的方法是抢占式的, 协程是自己来调度的

[堆栈概念参考](https://blog.csdn.net/K346K346/article/details/80849966)

协程对于计算密集型提升不了太多性能, 协程主要提升IO操作的效率

协程在遇到IO操作时, 会把权利交出来, 交给其他协程

所以如果是密集型计算, 协程不会把控制权交出来

# 高并发后端优化

## 10.2 使用DataLoader

处理N+1问题, 可以参考这个库的解决https://github.com/graphql/dataloader

主要思路是 当程序未正在访问数据库时, 会把同时在等待的请求参数都汇总在一起, 一起请求数据库

# 笔者总结

这本书是以实战的思路去介绍Graphql, 但是也引入了大量跟Graphql不紧关联的技术

所以 很多东西都一笔带过, 主要为了给读者介绍下相关的技术

评分3.5